<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0087)http://www.phpclasses.org/browse.html/file/5137/download/1/name/Image_Toolbox.class.php -->

<html>
<HEAD>
	<META http-equiv=Content-Type content="text/html; charset=ks_c_5601-1987">
	<META content="MSHTML 6.00.2800.1264" name=GENERATOR>
</HEAD>

<body>
<PRE>&lt;?php
/**
 * Image_Toolbox.class.php -- PHP image manipulation class
 *
 * Copyright (C) 2003 Martin Theimer &lt;pappkamerad@decoded.net&gt;
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
 * GNU General Public License &lt;http://www.opensource.org/gpl-license.html&gt;
 * for more details..
 *
 * The latest version of Image_Toolbox can be obtained from:
 * http://www.phpclasses.org/image_toolbox
 *
 * @author Martin Theimer &lt;pappkamerad@decoded.net&gt;
 * @copyright Copyright (C) 2003 Martin Theimer
 * @version 0.9
 * @package Image_Toolbox
 * @link http://www.decoded.net/projects/image_toolbox
 */

// $Id: Image_Toolbox.class.php,v 1.5 2003/11/03 20:55:53 mtheimer Exp $
if (!defined('IMAGE_TOOLBOX_DEFAULT_JPEG_QUALITY')) {
	define('IMAGE_TOOLBOX_DEFAULT_JPEG_QUALITY', 75);
}
if (!defined('IMAGE_TOOLBOX_DEFAULT_8BIT_COLORS')) {
	define('IMAGE_TOOLBOX_DEFAULT_8BIT_COLORS', 256);
}
if (!defined('IMAGE_TOOLBOX_BIAS_HORIZONTAL')) {
	define('IMAGE_TOOLBOX_BIAS_HORIZONTAL', 1);
}
if (!defined('IMAGE_TOOLBOX_BIAS_VERTICAL')) {
	define('IMAGE_TOOLBOX_BIAS_VERTICAL', 0);
}
if (!defined('IMAGE_TOOLBOX_BLEND_COPY')) {
	define('IMAGE_TOOLBOX_BLEND_COPY', 1);
}
if (!defined('IMAGE_TOOLBOX_BLEND_MULTIPLY')) {
	define('IMAGE_TOOLBOX_BLEND_MULTIPLY', 2);
}
if (!defined('IMAGE_TOOLBOX_BLEND_SCREEN')) {
	define('IMAGE_TOOLBOX_BLEND_SCREEN', 3);
}
if (!defined('IMAGE_TOOLBOX_BLEND_DIFFERENCE')) {
	define('IMAGE_TOOLBOX_BLEND_DIFFERENCE', 4);
}
if (!defined('IMAGE_TOOLBOX_BLEND_NEGATION')) {
	define('IMAGE_TOOLBOX_BLEND_NEGATION', 5);
}
if (!defined('IMAGE_TOOLBOX_BLEND_EXCLUTION')) {
	define('IMAGE_TOOLBOX_BLEND_EXCLUSION', 6);
}
if (!defined('IMAGE_TOOLBOX_BLEND_OVERLAY')) {
	define('IMAGE_TOOLBOX_BLEND_OVERLAY', 7);
}
/**
 * PHP image manipulation class
 *
 * This class provides an easy to use library to the PHP GD-based imagefunctions
 *
 * @author Martin Theimer &lt;pappkamerad@decoded.net&gt;
 * @copyright 2003, Martin Theimer
 * @package Image_Toolbox
 * @link http://www.decoded.net/projects/image_class
 * @version [CVS] $Id: Image_Toolbox.class.php,v 1.5 2003/11/03 20:55:53 mtheimer Exp $
 */
class Image_Toolbox {
	/**
	 * The prefix for every error message
	 *
	 * @access private
	 * @var string
	 */
	var $_error_prefix = 'Image: ';

	/**
	 * Defines imagetypes and how they are supported by the server
	 *
	 * @access private
	 * @var array
	 */
	var $_types = array (
		1 =&gt; array (
			'ext' =&gt; 'gif',
			'mime' =&gt; 'image/gif',
			'supported' =&gt; 0
		),
		2 =&gt; array (
			'ext' =&gt; 'jpg',
			'mime' =&gt; 'image/jpeg',
			'supported' =&gt; 0
		),
		3 =&gt; array (
			'ext' =&gt; 'png',
			'mime' =&gt; 'image/png',
			'supported' =&gt; 0
		)
	);

	/**
	 * Which PHP image resize function to be used
	 * imagecopyresampled only supported with GD &gt;= 2.0
	 *
	 * @access private
	 * @var string
	 */
	var $_resize_function = 'imagecopyresampled';
	/**
	 * Stores all image resource data
	 *
	 * @access private
	 * @var array
	 */
	var $_img = array (
		'main' =&gt; array (
			'resource' =&gt; 0,
			'width' =&gt; 0,
			'height' =&gt; 0,
			'bias' =&gt; 0,
			'aspectratio' =&gt; 0,
			'type' =&gt; 0,
			'output_type' =&gt; 0,
			'indexedcolors' =&gt; 0,
			'color' =&gt; -1
		)
	);

	/**
	 * Which PHP image create function to be used
	 * imagecreatetruecolor only supported with GD &gt;= 2.0
	 *
	 * @access private
	 * @var string
	 */
	var $_imagecreatefunction = '';

	/**
	 * The class constructor.
	 *
	 * Determines the image features of the server and sets the according values.&lt;br&gt;
	 * Additionally you can specify a image to be created/loaded. like {@link addImage() addImage}.
	 *
	 * If no parameter is given, no image resource will be generated&lt;br&gt;
	 * Or:&lt;br&gt;
	 * &lt;i&gt;string&lt;/i&gt; &lt;b&gt;$file&lt;/b&gt; imagefile to load&lt;br&gt;
	 * Or:&lt;br&gt;
	 * &lt;i&gt;integer&lt;/i&gt; &lt;b&gt;$width&lt;/b&gt; imagewidth of new image to be created&lt;br&gt;
	 * &lt;i&gt;integer&lt;/i&gt; &lt;b&gt;$height&lt;/b&gt; imageheight of new image to be created&lt;br&gt;
	 * &lt;i&gt;string&lt;/i&gt; &lt;b&gt;$fillcolor&lt;/b&gt; optional fill the new image with this color (hexformat, e.g. '#FF0000')&lt;br&gt;
	 */
	function Image_Toolbox() {
		$args = func_get_args();
		$argc = func_num_args();

		//get GD information. see what types we can handle
		$gd_info = $this-&gt;_gd_info();
		preg_match("/\A[\D]*(\d+\.\d+)[\D]*\Z/", $gd_info['GD Version'], $matches);
		list($this-&gt;_gd_version_string, $this-&gt;_gd_version) = $matches;
		if ((float)$this-&gt;_gd_version &gt;= 2.0) {
			$this-&gt;_imagecreatefunction = 'imagecreatetruecolor';
			$this-&gt;_resize_function = 'imagecopyresampled';
		} else {
			$this-&gt;_imagecreatefunction = 'imagecreate';
			$this-&gt;_resize_function = 'imagecopyresized';
		}

		$this-&gt;_gd_ttf = $gd_info['FreeType Support'];
		$this-&gt;_gd_ps = $gd_info['T1Lib Support'];
		if ($gd_info['GIF Read Support']) {
			$this-&gt;_types[1]['supported'] = 1;
			if ($gd_info['GIF Create Support']) {
				$this-&gt;_types[1]['supported'] = 2;
			}
		}
		if ($gd_info['JPG Support']) {
			$this-&gt;_types[2]['supported'] = 2;
		}
		if ($gd_info['PNG Support']) {
			$this-&gt;_types[3]['supported'] = 2;
		}

		//load or create main image
		if ($argc == 0) {
			return true;
		} else {
			if ($this-&gt;_addImage($argc, $args)) {
				foreach ($this-&gt;_img['operator'] as $key =&gt; $value) {
					$this-&gt;_img['main'][$key] = $value;
				}
				$this-&gt;_img['main']['output_type'] = $this-&gt;_img['main']['type'];
				unset($this-&gt;_img['operator']);
				return true;
			} else {
				trigger_error($this-&gt;_error_prefix . 'No appropriate constructor found.', E_USER_ERROR);
				return null;
			}
		}
	}
	/**
	 * Returns an assocative array with information about the image features of this server
	 *
	 * Array values:
	 * &lt;ul&gt;
	 * &lt;li&gt;'gd_version' -&gt; what GD version is installed on this server (e.g. 2.0)&lt;/li&gt;
	 * &lt;li&gt;'gif' -&gt; 0 = not supported, 1 = reading is supported, 2 = creating is supported&lt;/li&gt;
	 * &lt;li&gt;'jpg' -&gt; 0 = not supported, 1 = reading is supported, 2 = creating is supported&lt;/li&gt;
	 * &lt;li&gt;'png' -&gt; 0 = not supported, 1 = reading is supported, 2 = creating is supported&lt;/li&gt;
	 * &lt;li&gt;'ttf' -&gt; TTF text creation. true = supported, false = not supported
	 * &lt;/ul&gt;
	 *
	 * @return array
	 */
	function getServerFeatures() {
		$features = array();
		$features['gd_version'] = $this-&gt;_gd_version;
		$features['gif'] = $this-&gt;_types[1]['supported'];
		$features['jpg'] = $this-&gt;_types[2]['supported'];
		$features['png'] = $this-&gt;_types[3]['supported'];
		$features['ttf'] = $this-&gt;_gd_ttf;
		return $features;
	}
	/**
	 * Flush all image resources and init a new one
	 *
	 * Parameter:&lt;br&gt;
	 * &lt;i&gt;string&lt;/i&gt; &lt;b&gt;$file&lt;/b&gt; imagefile to load&lt;br&gt;
	 * Or:&lt;br&gt;
	 * &lt;i&gt;integer&lt;/i&gt; &lt;b&gt;$width&lt;/b&gt; imagewidth of new image to be created&lt;br&gt;
	 * &lt;i&gt;integer&lt;/i&gt; &lt;b&gt;$height&lt;/b&gt; imageheight of new image to be created&lt;br&gt;
	 * &lt;i&gt;string&lt;/i&gt; &lt;b&gt;$fillcolor&lt;/b&gt; optional fill the new image with this color (hexformat, e.g. '#FF0000')&lt;br&gt;
	 */
	function newImage() {
		$args = func_get_args();
		$argc = func_num_args();

		if ($this-&gt;_addImage($argc, $args)) {
			foreach ($this-&gt;_img['operator'] as $key =&gt; $value) {
				$this-&gt;_img['main'][$key] = $value;
			}
			$this-&gt;_img['main']['output_type'] = $this-&gt;_img['main']['type'];
			unset($this-&gt;_img['operator']);
			return true;
		} else {
			trigger_error($this-&gt;_error_prefix . 'No appropriate constructor found.', E_USER_ERROR);
			return null;
		}
	}
	/**
	 * Reimplements the original PHP {@link gd_info()} function for older PHP versions
	 *
	 * @access private
	 * @return array associative array with info about the GD library of the server
	 */
	function _gd_info() {
		$array = array(
			"GD Version" =&gt; "",
			"FreeType Support" =&gt; false,
			"FreeType Linkage" =&gt; "",
			"T1Lib Support" =&gt; false,
			"GIF Read Support" =&gt; false,
			"GIF Create Support" =&gt; false,
			"JPG Support" =&gt; false,
			"PNG Support" =&gt; false,
			"WBMP Support" =&gt; false,
			"XBM Support" =&gt; false
		);

		$gif_support = 0;
		ob_start();
		eval("phpinfo();");
		$info = ob_get_contents();
		ob_end_clean();

		foreach(explode("\n", $info) as $line) {
			if(strpos($line, "GD Version") !== false)
				$array["GD Version"] = trim(str_replace("GD Version", "", strip_tags($line)));
			if(strpos($line, "FreeType Support") !== false)
				$array["FreeType Support"] = trim(str_replace("FreeType Support", "", strip_tags($line)));
			if(strpos($line, "FreeType Linkage") !== false)
				$array["FreeType Linkage"] = trim(str_replace("FreeType Linkage", "", strip_tags($line)));
			if(strpos($line, "T1Lib Support") !== false)
				$array["T1Lib Support"] = trim(str_replace("T1Lib Support", "", strip_tags($line)));
			if(strpos($line, "GIF Read Support") !== false)
				$array["GIF Read Support"] = trim(str_replace("GIF Read Support", "", strip_tags($line)));
			if(strpos($line, "GIF Create Support") !== false)
				$array["GIF Create Support"] = trim(str_replace("GIF Create Support", "", strip_tags($line)));
			if(strpos($line, "GIF Support") !== false)
				$gif_support = trim(str_replace("GIF Support", "", strip_tags($line)));
			if(strpos($line, "JPG Support") !== false)
				$array["JPG Support"] = trim(str_replace("JPG Support", "", strip_tags($line)));
			if(strpos($line, "PNG Support") !== false)
				$array["PNG Support"] = trim(str_replace("PNG Support", "", strip_tags($line)));
			if(strpos($line, "WBMP Support") !== false)
				$array["WBMP Support"] = trim(str_replace("WBMP Support", "", strip_tags($line)));
			if(strpos($line, "XBM Support") !== false)
				$array["XBM Support"] = trim(str_replace("XBM Support", "", strip_tags($line)));
		}

		if($gif_support === "enabled") {
			$array["GIF Read Support"] = true;
			$array["GIF Create Support"] = true;
		}
		if($array["FreeType Support"] === "enabled") {
			$array["FreeType Support"] = true;
		}

		if($array["T1Lib Support"] === "enabled") {
			$array["T1Lib Support"] = true;
		}

		if($array["GIF Read Support"] === "enabled") {
			$array["GIF Read Support"] = true;
		}

		if($array["GIF Create Support"] === "enabled") {
			$array["GIF Create Support"] = true;
		}
		if($array["JPG Support"] === "enabled") {
			$array["JPG Support"] = true;
		}

		if($array["PNG Support"] === "enabled") {
			$array["PNG Support"] = true;
		}

		if($array["WBMP Support"] === "enabled") {
			$array["WBMP Support"] = true;
		}

		if($array["XBM Support"] === "enabled") {
			$array["XBM Support"] = true;
		}
		return $array;
	}
	/**
	 * Convert a color defined in hexvalues to the PHP color format
	 *
	 * @access private
	 * @param string $hex color value in hexformat (e.g. '#FF0000')
	 * @return integer color value in PHP format
	 */
	function _hexToPHPColor($hex) {
		$length = strlen($hex);
		$dr = hexdec(substr($hex, $length - 6, 2));
		$dg = hexdec(substr($hex, $length - 4, 2));
		$db = hexdec(substr($hex, $length - 2, 2));
		$color = ($dr &lt;&lt; 16) + ($dg &lt;&lt; 8) + $db;
		return $color;
	}

	/**
	 * Convert a color defined in hexvalues to corresponding dezimal values
	 *
	 * @access private
	 * @param string $hex color value in hexformat (e.g. '#FF0000')
	 * @return array associative array with color values in dezimal format (fields: 'red', 'green', 'blue')
	 */
	function _hexToDecColor($hex) {
		$length = strlen($hex);
		$color['red'] = hexdec(substr($hex, $length - 6, 2));
		$color['green'] = hexdec(substr($hex, $length - 4, 2));
		$color['blue'] = hexdec(substr($hex, $length - 2, 2));
		return $color;
	}
	/**
	 * Generate a new image resource based on the given parameters
	 *
	 * Parameter:
	 * &lt;i&gt;string&lt;/i&gt; &lt;b&gt;$file&lt;/b&gt; imagefile to load&lt;br&gt;
	 * Or:&lt;br&gt;
	 * &lt;i&gt;integer&lt;/i&gt; &lt;b&gt;$width&lt;/b&gt; imagewidth of new image to be created&lt;br&gt;
	 * &lt;i&gt;integer&lt;/i&gt; &lt;b&gt;$height&lt;/b&gt; imageheight of new image to be created&lt;br&gt;
	 * &lt;i&gt;string&lt;/i&gt; &lt;b&gt;$fillcolor&lt;/b&gt; optional fill the new image with this color (hexformat, e.g. '#FF0000')&lt;br&gt;
	 *
	 * @access private
	 */
	function _addImage($argc, $args) {
		if (($argc == 2 || $argc == 3) &amp;&amp; is_int($args[0]) &amp;&amp; is_int($args[1]) &amp;&amp; (is_string($args[2]) || !isset($args[2]))) {
			//neues leeres bild mit width und height (fillcolor optional)
			$this-&gt;_img['operator']['width'] = $args[0];
			$this-&gt;_img['operator']['height'] = $args[1];
			($this-&gt;_img['operator']['width'] &gt;= $this-&gt;_img['operator']['height']) ? ($this-&gt;_img['operator']['bias'] = IMAGE_TOOLBOX_BIAS_HORIZONTAL) : ($this-&gt;_img['operator']['bias'] = IMAGE_TOOLBOX_BIAS_VERTICAL);
			$this-&gt;_img['operator']['aspectratio'] = $this-&gt;_img['operator']['width'] / $this-&gt;_img['operator']['height'];
			$this-&gt;_img['operator']['indexedcolors'] = 0;
			$functionname = $this-&gt;_imagecreatefunction;
			$this-&gt;_img['operator']['resource'] = $functionname($this-&gt;_img['operator']['width'], $this-&gt;_img['operator']['height']);
			// set default type jpg.
			$this-&gt;_img['operator']['type'] = 2;
			if (isset($args[2]) &amp;&amp; is_string($args[2])) {
				//neues bild mit farbe f걄len
				$fillcolor = $this-&gt;_hexToPHPColor($args[2]);
				imagefill($this-&gt;_img['operator']['resource'], 0, 0, $fillcolor);
				$this-&gt;_img['operator']['color'] = $fillcolor;
			} else {
				$this-&gt;_img['operator']['color'] = 0;
			}
		} elseif ($argc == 1 &amp;&amp; is_string($args[0])) {
			//bild aus datei laden. width und height original gr봲se
			$this-&gt;_img['operator'] = $this-&gt;_loadFile($args[0]);
			$this-&gt;_img['operator']['indexedcolors'] = imagecolorstotal($this-&gt;_img['operator']['resource']);
			$this-&gt;_img['operator']['color'] = -1;
		} else {
			return false;
		}
		return true;
	}
	/**
	 * Loads a image file
	 *
	 * @access private
	 * @param string $filename imagefile to load
	 * @return array associative array with the loaded filedata
	 */
	function _loadFile($filename) {
		if (file_exists($filename)) {
			$info = getimagesize($filename);
			$filedata['width'] = $info[0];
			$filedata['height'] = $info[1];
			($filedata['width'] &gt;= $filedata['height']) ? ($filedata['bias'] = IMAGE_TOOLBOX_BIAS_HORIZONTAL) : ($filedata['bias'] = IMAGE_TOOLBOX_BIAS_VERTICAL);
				$filedata['aspectratio'] = $filedata['width'] / $filedata['height'];
			$filedata['type'] = $info[2];
			if ($this-&gt;_types[$filedata['type']]['supported'] &lt; 1) {
				trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$filedata['type']]['ext'].') not supported for reading.', E_USER_ERROR);
				return null;
			}
			switch ($filedata['type']) {
				case 1:
					$dummy = imagecreatefromgif($filename);
					$functionname = $this-&gt;_imagecreatefunction;
					$filedata['resource'] = $functionname($filedata['width'], $filedata['height']);
					imagecopy($filedata['resource'], $dummy, 0, 0, 0, 0, $filedata['width'], $filedata['height']);
					imagedestroy($dummy);
					break;

				case 2:
					$filedata['resource'] = imagecreatefromjpeg($filename);
					break;

				case 3:
					$dummy = imagecreatefrompng($filename);
					if (imagecolorstotal($dummy) != 0) {
						$functionname = $this-&gt;_imagecreatefunction;
						$filedata['resource'] = $functionname($filedata['width'], $filedata['height']);
						imagecopy($filedata['resource'], $dummy, 0, 0, 0, 0, $filedata['width'], $filedata['height']);
					} else {
						$filedata['resource'] = $dummy;
					}
					unset($dummy);
					break;

				default:
					trigger_error($this-&gt;_error_prefix . 'Imagetype not supported.', E_USER_ERROR);
					return null;
			}
			return $filedata;
		} else {
			trigger_error($this-&gt;_error_prefix . 'Imagefile (' . $filename . ') does not exist.', E_USER_ERROR);
			return null;
		}
	}

	/**
	 * Output a image to the browser
	 *
	 * $output_type can be one of the following:&lt;br&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;'gif' -&gt; gif image (if supported) (8-bit indexed colors)&lt;/li&gt;
	 * &lt;li&gt;'png' -&gt; png image (if supported) (truecolor)&lt;/li&gt;
	 * &lt;li&gt;'png8' -&gt; png image (if supported) (8-bit indexed colors)&lt;/li&gt;
	 * &lt;li&gt;'jpg' -&gt; jpeg image (if supported) (truecolor)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * (default: same as original)
	 *
	 * $dither:&lt;br&gt;
	 * If this is true than dither is used on the conversion from truecolor to 8-bit indexed imageformats (png8, gif)&lt;br&gt;
	 * (default = false)
	 *
	 * @param string|integer $output_type type of outputted image
	 * @param integer $output_quality jpeg quality of outputted image (default: IMAGE_TOOLBOX_DEFAULT_JPEG_QUALITY)
	 * @param bool $dither use dither
	 * @return bool true on success, otherwise false
	 */
	function output($output_type = false, $output_quality = false, $dither = false) {
		if ($output_type === false) {
			$output_type = $this-&gt;_img['main']['output_type'];
		}
		switch ($output_type) {
			case 1:
			case 'gif':
			case 'GIF':
				if ($this-&gt;_types[1]['supported'] &lt; 2) {
					trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$output_type]['ext'].') not supported for creating/writing.', E_USER_ERROR);
					return null;
				}
				header ('Content-type: ' . $this-&gt;_types[$output_type]['mime']);
				if ($this-&gt;_gd_version &gt;= 2.0) {
					if ($this-&gt;_img['main']['indexedcolors'] == 0) {
						$dummy = imagecreatetruecolor($this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
						imagecopy($dummy, $this-&gt;_img['main']['resource'], 0, 0, 0, 0, $this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
						if ($output_quality === false) {
							$output_quality = IMAGE_TOOLBOX_DEFAULT_8BIT_COLORS;
						}
						imagetruecolortopalette($dummy, $dither, $output_quality);
					}
					imagegif($dummy);
					imagedestroy($dummy);
				}
				else {
					imagegif($this-&gt;_img['main']['resource']);
				}
				break;

			case 2:
			case '2':
			case 'jpg':
			case 'jpeg':
			case 'JPG':
			case 'JPEG':
				if ($this-&gt;_types[2]['supported'] &lt; 2) {
					trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$output_type]['ext'].') not supported for creating/writing.', E_USER_ERROR);
					return null;
				}
				header ('Content-type: ' . $this-&gt;_types[$output_type]['mime']);
				if ($output_quality === false) {
					$output_quality = IMAGE_TOOLBOX_DEFAULT_JPEG_QUALITY;
				}
				imagejpeg($this-&gt;_img['main']['resource'], '', $output_quality);
				break;

			case 3:
			case '3':
			case 'png':
			case 'PNG':
			case 'png24':
			case 'PNG24':
				if ($this-&gt;_types[3]['supported'] &lt; 2) {
					trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$output_type]['ext'].') not supported for creating/writing.', E_USER_ERROR);
					return null;
				}
				header ('Content-type: ' . $this-&gt;_types[$output_type]['mime']);
				imagepng($this-&gt;_img['main']['resource']);
				break;

			case 4:
			case '4':
			case 'png8':
			case 'PNG8':
				if ($this-&gt;_types[3]['supported'] &lt; 2) {
					trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$output_type]['ext'].') not supported for creating/writing.', E_USER_ERROR);
					return null;
				}
				header ('Content-type: ' . $this-&gt;_types[$output_type]['mime']);
				if ($this-&gt;_gd_version &gt;= 2.0) {
					if ($this-&gt;_img['main']['indexedcolors'] == 0) {
						$dummy = imagecreatetruecolor($this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
						imagecopy($dummy, $this-&gt;_img['main']['resource'], 0, 0, 0, 0, $this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
						if ($output_quality === false) {
							$output_quality = IMAGE_TOOLBOX_DEFAULT_8BIT_COLORS;
						}
						imagetruecolortopalette($dummy, $dither, $output_quality);
					}
					imagepng($dummy);
					imagedestroy($dummy);
				}
				else {
					imagepng($this-&gt;_img['main']['resource']);
				}
				break;

			default:
				trigger_error($this-&gt;_error_prefix . 'Output-Imagetype not supported.', E_USER_ERROR);
				return null;
		}
		return true;
	}

	/**
	 * Save a image to disk
	 *
	 * $output_type can be one of the following:&lt;br&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;'gif' -&gt; gif image (if supported) (8-bit indexed colors)&lt;/li&gt;
	 * &lt;li&gt;'png' -&gt; png image (if supported) (truecolor)&lt;/li&gt;
	 * &lt;li&gt;'png8' -&gt; png image (if supported) (8-bit indexed colors)&lt;/li&gt;
	 * &lt;li&gt;'jpg' -&gt; jpeg image (if supported) (truecolor)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * (default: same as original)
	 *
	 * $dither:&lt;br&gt;
	 * If this is true than dither is used on the conversion from truecolor to 8-bit indexed imageformats (png8, gif)&lt;br&gt;
	 * (default = false)
	 *
	 * @param string $filename filename of saved image
	 * @param string|integer $output_type type of saved image
	 * @param integer $output_quality jpeg quality of saved image (default: IMAGE_TOOLBOX_DEFAULT_JPEG_QUALITY)
	 * @param bool $dither use dither
	 * @return bool true on success, otherwise false
	 */
	function save($filename, $output_type = false, $output_quality = false, $dither = false) {
		if ($output_type === false) {
			$output_type = $this-&gt;_img['main']['output_type'];
		}
		switch ($output_type) {
			case 1:
			case 'gif':
			case 'GIF':
				if ($this-&gt;_types[1]['supported'] &lt; 2) {
					trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$output_type]['ext'].') not supported for creating/writing.', E_USER_ERROR);
					return null;
				}
				if ($this-&gt;_gd_version &gt;= 2.0) {
					if ($this-&gt;_img['main']['indexedcolors'] == 0) {
						$dummy = imagecreatetruecolor($this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
						imagecopy($dummy, $this-&gt;_img['main']['resource'], 0, 0, 0, 0, $this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
						if ($output_quality === false) {
							$output_quality = IMAGE_TOOLBOX_DEFAULT_8BIT_COLORS;
						}
						imagetruecolortopalette($dummy, $dither, $output_quality);
					}
					imagegif($dummy, $filename);
					imagedestroy($dummy);
				}
				else {
					imagegif($this-&gt;_img['main']['resource']);
				}
				break;

			case 2:
			case '2':
			case 'jpg':
			case 'jpeg':
			case 'JPG':
			case 'JPEG':
				if ($this-&gt;_types[2]['supported'] &lt; 2) {
					trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$output_type]['ext'].') not supported for creating/writing.', E_USER_ERROR);
					return null;
				}
				if ($output_quality === false) {
					$output_quality = IMAGE_TOOLBOX_DEFAULT_JPEG_QUALITY;
				}
				imagejpeg($this-&gt;_img['main']['resource'], $filename, $output_quality);
				break;

			case 3:
			case '3':
			case 'png':
			case 'PNG':
			case 'png24':
			case 'PNG24':
				if ($this-&gt;_types[3]['supported'] &lt; 2) {
					trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$output_type]['ext'].') not supported for creating/writing.', E_USER_ERROR);
					return null;
				}
				header ('Content-type: ' . $this-&gt;_types[$output_type]['mime']);
				imagepng($this-&gt;_img['main']['resource'], $filename);
				break;

			case 4:
			case '4':
			case 'png8':
			case 'PNG8':
				if ($this-&gt;_types[3]['supported'] &lt; 2) {
					trigger_error($this-&gt;_error_prefix . 'Imagetype ('.$this-&gt;_types[$output_type]['ext'].') not supported for creating/writing.', E_USER_ERROR);
					return null;
				}
				if ($this-&gt;_gd_version &gt;= 2.0) {
					if ($this-&gt;_img['main']['indexedcolors'] == 0) {
						$dummy = imagecreatetruecolor($this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
						imagecopy($dummy, $this-&gt;_img['main']['resource'], 0, 0, 0, 0, $this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
						if ($output_quality === false) {
							$output_quality = IMAGE_TOOLBOX_DEFAULT_8BIT_COLORS;
						}
						imagetruecolortopalette($dummy, $dither, $output_quality);
					}
					imagepng($dummy, $filename);
					imagedestroy($dummy);
				}
				else {
					imagegif($this-&gt;_img['main']['resource'], $filename);
				}
				break;

			default:
				trigger_error($this-&gt;_error_prefix . 'Output-Imagetype not supported.', E_USER_ERROR);
				return null;
		}
		return true;
	}

	/**
	 * Sets the resize method of choice
	 *
	 * $method can be one of the following:&lt;br&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;'resize' -&gt; supported by every version of GD (fast but ugly resize of image)&lt;/li&gt;
	 * &lt;li&gt;'resample' -&gt; only supported by GD version &gt;= 2.0 (slower but antialiased resize of image)&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @param string|integer $method resize method
	 * @return bool true on success, otherwise false
	 */
	function setResizeMethod($method) {
		switch ($method) {
			case 1:
			case '1':
			case 'resize':
				$this-&gt;_resize_function = 'imagecopyresized';
				break;

			case 2:
			case '2':
			case 'resample':
				if ((float)$this-&gt;_gd_version &lt;= 2.0) {
					// no error message. just return false.
					return null;
				}
				$this-&gt;_resize_function = 'imagecopyresampled';
				break;

			default:
				trigger_error($this-&gt;_error_prefix . 'Resizemethod not supported.', E_USER_ERROR);
				return null;
		}
		return true;
	}

	/**
	 * Resize the current image
	 *
	 * if $width = 0 the new width will be calculated from the $height value preserving the correct aspectratio.&lt;br&gt;
	 *
	 * if $height = 0 the new height will be calculated from the $width value preserving the correct aspectratio.&lt;br&gt;
	 *
	 * if $crop is set to true the image will be cropped if necessary to preserve the aspectratio and avoid image distortions.&lt;br&gt;
	 * (default = false)
	 *
	 * if $autorotate is set to true the given $width and $height values may "change place" if the given image bias is different from the original one.&lt;br&gt;
	 * if either $width or $height is 0, the new size will be applied to either the new width or the new height based on the bias value of the original image.&lt;br&gt;
	 * (default = false)
	 *
	 * @param integer $width new width of image
	 * @param integer $height new height of image
	 * @param bool $crop use image cropping
	 * @param bool $autorotate use autorotating
	 * @return bool true on success, otherwise false
	 */
	function newOutputSize($width, $height, $crop = false, $autorotate = false) {
		if ($width &gt; 0 &amp;&amp; $height &gt; 0 &amp;&amp; is_int($width) &amp;&amp; is_int($height)) {
			//ignore aspectratio
			if (!$crop) {
				//do not crop to get correct aspectratio
				($width &gt;= $height) ? ($this-&gt;_img['target']['bias'] = IMAGE_TOOLBOX_BIAS_HORIZONTAL) : ($this-&gt;_img['target']['bias'] = IMAGE_TOOLBOX_BIAS_VERTICAL);
				if ($this-&gt;_img['main']['bias'] == $this-&gt;_img['target']['bias'] || !$autorotate) {
					$this-&gt;_img['target']['width'] = $width;
					$this-&gt;_img['target']['height'] = $height;
				} else {
					$this-&gt;_img['target']['width'] = $height;
					$this-&gt;_img['target']['height'] = $width;
				}
				$this-&gt;_img['target']['aspectratio'] = $this-&gt;_img['target']['width'] / $this-&gt;_img['target']['height'];

				$cpy_w = $this-&gt;_img['main']['width'];
				$cpy_h = $this-&gt;_img['main']['height'];
				$cpy_w_offset = 0;
				$cpy_h_offset = 0;
			} else {
				//crop to get correct aspectratio
				($width &gt;= $height) ? ($this-&gt;_img['target']['bias'] = IMAGE_TOOLBOX_BIAS_HORIZONTAL) : ($this-&gt;_img['target']['bias'] = IMAGE_TOOLBOX_BIAS_VERTICAL);
				if ($this-&gt;_img['main']['bias'] == $this-&gt;_img['target']['bias'] || !$autorotate) {
					$this-&gt;_img['target']['width'] = $width;
					$this-&gt;_img['target']['height'] = $height;
				} else {
					$this-&gt;_img['target']['width'] = $height;
					$this-&gt;_img['target']['height'] = $width;
				}
				$this-&gt;_img['target']['aspectratio'] = $this-&gt;_img['target']['width'] / $this-&gt;_img['target']['height'];

				if ($this-&gt;_img['main']['width'] / $this-&gt;_img['target']['width'] &gt;= $this-&gt;_img['main']['height'] / $this-&gt;_img['target']['height']) {
					$cpy_h = $this-&gt;_img['main']['height'];
					$cpy_w = (integer) $this-&gt;_img['main']['height'] * $this-&gt;_img['target']['aspectratio'];
					$cpy_w_offset = (integer) ($this-&gt;_img['main']['width'] - $cpy_w) / 2;
					$cpy_h_offset = 0;
				} else {
					$cpy_w = $this-&gt;_img['main']['width'];
					$cpy_h = (integer) $this-&gt;_img['main']['width'] / $this-&gt;_img['target']['aspectratio'];
					$cpy_h_offset = (integer) ($this-&gt;_img['main']['height'] - $cpy_h) / 2;
					$cpy_w_offset = 0;
				}
			}
		} elseif (($width == 0 &amp;&amp; $height &gt; 0) || ($width &gt; 0 &amp;&amp; $height == 0) &amp;&amp; is_int($width) &amp;&amp; is_int($height)) {
			//keep aspectratio
			if ($autorotate == true) {
				if ($this-&gt;_img['main']['bias'] == IMAGE_TOOLBOX_BIAS_HORIZONTAL &amp;&amp; $width &gt; 0) {
					$height = $width;
					$width = 0;
				}
				elseif ($this-&gt;_img['main']['bias'] == IMAGE_TOOLBOX_BIAS_VERTICAL &amp;&amp; $height &gt; 0) {
					$width = $height;
					$height = 0;
				}
			}
			($width &gt;= $height) ? ($this-&gt;_img['target']['bias'] = IMAGE_TOOLBOX_BIAS_HORIZONTAL) : ($this-&gt;_img['target']['bias'] = IMAGE_TOOLBOX_BIAS_VERTICAL);
			if ($width != 0) {
				$this-&gt;_img['target']['width'] = $width;
				$this-&gt;_img['target']['height'] = (integer) $width / $this-&gt;_img['main']['aspectratio'];
			} else {
				$this-&gt;_img['target']['height'] = $height;
				$this-&gt;_img['target']['width'] = (integer) $height * $this-&gt;_img['main']['aspectratio'];
			}
			$this-&gt;_img['target']['aspectratio'] = $this-&gt;_img['main']['aspectratio'];

			$cpy_w = $this-&gt;_img['main']['width'];
			$cpy_h = $this-&gt;_img['main']['height'];
			$cpy_w_offset = 0;
			$cpy_h_offset = 0;
		} else {
			trigger_error($this-&gt;_error_prefix . 'Outputwidth and -height must be integers greater zero.', E_USER_ERROR);
			return null;
		}

		//create resized picture
		$functionname = $this-&gt;_imagecreatefunction;
		$dummy = $functionname($this-&gt;_img['target']['width'] + 1, $this-&gt;_img['target']['height'] + 1);
		eval($this-&gt;_resize_function . '($dummy, $this-&gt;_img["main"]["resource"], 0, 0, $cpy_w_offset, $cpy_h_offset, $this-&gt;_img["target"]["width"], $this-&gt;_img["target"]["height"], $cpy_w, $cpy_h);');
		$this-&gt;_img['target']['resource'] = $functionname($this-&gt;_img['target']['width'], $this-&gt;_img['target']['height']);
		imagecopy($this-&gt;_img['target']['resource'], $dummy, 0, 0, 0, 0, $this-&gt;_img['target']['width'], $this-&gt;_img['target']['height']);
		imagedestroy($dummy);

		//update _img['main'] with new data
		foreach ($this-&gt;_img['target'] as $key =&gt; $value) {
			$this-&gt;_img['main'][$key] = $value;
		}
		unset ($this-&gt;_img['target']);

		return true;
	}
	/**
	 * Adds a new image resource based on the given parameters.
	 *
	 * It does not overwrite the existing image resource.&lt;br&gt;
	 * Instead it is used to load a second image to merge with the existing image.
	 *
	 * Parameter:&lt;br&gt;
	 * &lt;i&gt;string&lt;/i&gt; &lt;b&gt;$file&lt;/b&gt; imagefile to load&lt;br&gt;
	 * Or:&lt;br&gt;
	 * &lt;i&gt;integer&lt;/i&gt; &lt;b&gt;$width&lt;/b&gt; imagewidth of new image to be created&lt;br&gt;
	 * &lt;i&gt;integer&lt;/i&gt; &lt;b&gt;$height&lt;/b&gt; imageheight of new image to be created&lt;br&gt;
	 * &lt;i&gt;string&lt;/i&gt; &lt;b&gt;$fillcolor&lt;/b&gt; optional fill the new image with this color (hexformat, e.g. '#FF0000')&lt;br&gt;
	 */
	function addImage() {
		$args = func_get_args();
		$argc = func_num_args();

		if ($this-&gt;_addImage($argc, $args)) {
			return true;
		} else {
			trigger_error($this-&gt;_error_prefix . 'failed to add image.', E_USER_ERROR);
			return false;
		}
	}

	/**
	 * Blend two images.
	 *
	 * Original image and the image loaded with {@link addImage() addImage}&lt;br&gt;
	 * IMPORTANT: {@link imagecopymerge() imagecopymerged} doesn't work with PHP 4.3.2. Bug ID: {@link http://bugs.php.net/bug.php?id=24816 24816}&lt;br&gt;
	 *
	 * $x:&lt;br&gt;
	 * negative values are possible.&lt;br&gt;
	 * You can also use the following keywords ('left', 'center' or 'middle', 'right').&lt;br&gt;
	 * Additionally you can specify an offset in pixel with the keywords like this 'left +10'.&lt;br&gt;
	 * (default = 0)
	 *
	 * $y:&lt;br&gt;
	 * negative values are possible.&lt;br&gt;
	 * You can also use the following keywords ('top', 'center' or 'middle', 'bottom').&lt;br&gt;
	 * Additionally you can specify an offset in pixel with the keywords like this 'bottom -10'.&lt;br&gt;
	 * (default = 0)
	 *
	 * Possible values for $mode:
	 * &lt;ul&gt;
	 *	&lt;li&gt;IMAGE_TOOLBOX_BLEND_COPY&lt;/li&gt;
	 *	&lt;li&gt;IMAGE_TOOLBOX_BLEND_MULTIPLY&lt;/li&gt;
	 *	&lt;li&gt;IMAGE_TOOLBOX_BLEND_SCREEN&lt;/li&gt;
	 *	&lt;li&gt;IMAGE_TOOLBOX_BLEND_DIFFERENCE&lt;/li&gt;
	 *	&lt;li&gt;IMAGE_TOOLBOX_BLEND_EXCLUSION&lt;/li&gt;
	 *	&lt;li&gt;IMAGE_TOOLBOX_BLEND_OVERLAY&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * $percent:&lt;br&gt;
	 * alpha value in percent of blend effect (0 - 100)&lt;br&gt;
	 * (default = 100)
	 *
	 * @param string|integer $x Horizontal position of second image.
	 * @param integer $y Vertical position of second image. negative values are possible.
	 * @param integer $mode blend mode.
	 * @param integer $percent alpha value
	 */
	function blend($x = 0, $y = 0, $mode = IMAGE_TOOLBOX_BLEND_COPY, $percent = 100) {
		if (is_string($x) || is_string($y)) {
			list($xalign, $xalign_offset) = explode(" ", $x);
			list($yalign, $yalign_offset) = explode(" ", $y);
		}
		if (is_string($x)) {
			switch ($xalign) {
				case 'left':
					$dst_x = 0 + $xalign_offset;
					$src_x = 0;
					$src_w = $this-&gt;_img['operator']['width'];
					break;

				case 'right':
					$dst_x = ($this-&gt;_img['main']['width'] - $this-&gt;_img['operator']['width']) + $xalign_offset;
					$src_x = 0;
					$src_w = $this-&gt;_img['operator']['width'];
					break;

				case 'middle':
				case 'center':
					$dst_x = (($this-&gt;_img['main']['width'] / 2) - ($this-&gt;_img['operator']['width'] / 2)) + $yalign_offset;
					$src_x = 0;
					$src_w = $this-&gt;_img['operator']['width'];
					break;
			}
		} else {
			if ($x &gt;= 0) {
				$dst_x = $x;
				$src_x = 0;
				$src_w = $this-&gt;_img['operator']['width'];
			} else {
				$dst_x = 0;
				$src_x = abs($x);
				$src_w = $this-&gt;_img['operator']['width'] - $src_x;
			}
		}
		if (is_string($y)) {
			switch ($yalign) {
				case 'top':
					$dst_y = 0 + $yalign_offset;
					$src_y = 0;
					$src_h = $this-&gt;_img['operator']['height'];
					break;

				case 'bottom':
					$dst_y = ($this-&gt;_img['main']['height'] - $this-&gt;_img['operator']['height']) + $yalign_offset;
					$src_y = 0;
					$src_h = $this-&gt;_img['operator']['height'];
					break;

				case 'middle':
				case 'center':
					$dst_y = (($this-&gt;_img['main']['height'] / 2) - ($this-&gt;_img['operator']['height'] / 2)) + $yalign_offset;
					$src_y = 0;
					$src_h = $this-&gt;_img['operator']['height'];
					break;
			}
		} else {
			if ($y &gt;= 0) {
				$dst_y = $y;
				$src_y = 0;
				$src_h = $this-&gt;_img['operator']['height'];
			} else {
				$dst_y = 0;
				$src_y = abs($y);
				$src_h = $this-&gt;_img['operator']['height'] - $src_y;
			}
		}
		$this-&gt;_imageBlend($mode, $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h, $percent);
		return true;
	}

	/**
	 * Blend two images.
	 *
	 * @access private
	 */
	function _imageBlend($mode, $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h, $percent) {
		if ($mode == IMAGE_TOOLBOX_BLEND_COPY) {
			if ($percent == 100) {
				imagecopy($this-&gt;_img['main']['resource'], $this-&gt;_img['operator']['resource'], $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h);
			} else {
				imagecopymerge($this-&gt;_img['main']['resource'], $this-&gt;_img['operator']['resource'], $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h, $percent);
			}
		} else {
			$functionname = $this-&gt;_imagecreatefunction;
			$dummy = $functionname($src_w, $src_h);
			for ($y=0; $y &lt; $src_h; $y++) {
				for ($x=0; $x &lt; $src_w; $x++) {
					$colorindex = imagecolorat($this-&gt;_img['main']['resource'], $dst_x + $x, $dst_y + $y);
					$colorrgb1 = imagecolorsforindex($this-&gt;_img['main']['resource'], $colorindex);
					$colorindex = imagecolorat($this-&gt;_img['operator']['resource'], $src_x + $x, $src_y + $y);
					$colorrgb2 = imagecolorsforindex($this-&gt;_img['operator']['resource'], $colorindex);
					$colorblend = $this-&gt;_calculateBlendvalue($mode, $colorrgb1, $colorrgb2);
					$newcolor = imagecolorallocate($dummy, $colorblend['red'], $colorblend['green'], $colorblend['blue']);
					imagesetpixel($dummy, $x, $y, $newcolor);
				}
			}

			$this-&gt;_img['target']['resource'] = $functionname($this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
			imagecopy($this-&gt;_img['target']['resource'], $this-&gt;_img['main']['resource'], 0, 0, 0, 0, $this-&gt;_img['main']['width'], $this-&gt;_img['main']['height']);
			imagecopymerge($this-&gt;_img['target']['resource'], $dummy, $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h, $percent);

			$this-&gt;_img['main']['resource'] = $this-&gt;_img['target']['resource'];
			unset($this-&gt;_img['target']);
		}
	}

	/**
	 * Calculate blend values for given blend mode
	 *
	 * @access private
	 */
	function _calculateBlendvalue($mode, $colorrgb1, $colorrgb2) {
		switch ($mode) {
			case IMAGE_TOOLBOX_BLEND_MULTIPLY:
				$c['red'] = ($colorrgb1['red'] * $colorrgb2['red']) &gt;&gt; 8;
				$c['green'] = ($colorrgb1['green'] * $colorrgb2['green']) &gt;&gt; 8;
				$c['blue'] = ($colorrgb1['blue'] * $colorrgb2['blue']) &gt;&gt; 8;
				break;

			case IMAGE_TOOLBOX_BLEND_SCREEN:
				$c['red'] = 255 - ((255 - $colorrgb1['red']) * (255 - $colorrgb2['red']) &gt;&gt; 8);
				$c['green'] = 255 - ((255 - $colorrgb1['green']) * (255 - $colorrgb2['green']) &gt;&gt; 8);
				$c['blue'] = 255 - ((255 - $colorrgb1['blue']) * (255 - $colorrgb2['blue']) &gt;&gt; 8);
				break;

			case IMAGE_TOOLBOX_BLEND_DIFFERENCE:
				$c['red'] = abs($colorrgb1['red'] - $colorrgb2['red']);
				$c['green'] = abs($colorrgb1['green'] - $colorrgb2['green']);
				$c['blue'] = abs($colorrgb1['blue'] - $colorrgb2['blue']);
				break;

			case IMAGE_TOOLBOX_BLEND_NEGATION:
				$c['red'] = 255 - abs(255 - $colorrgb1['red'] - $colorrgb2['red']);
				$c['green'] = 255 - abs(255 - $colorrgb1['green'] - $colorrgb2['green']);
				$c['blue'] = 255 - abs(255 - $colorrgb1['blue'] - $colorrgb2['blue']);
				break;

			case IMAGE_TOOLBOX_BLEND_EXCLUTION:
				$c['red'] = $colorrgb1['red'] + $colorrgb2['red'] - (($colorrgb1['red'] * $colorrgb2['red']) &gt;&gt; 7);
				$c['green'] = $colorrgb1['green'] + $colorrgb2['green'] - (($colorrgb1['green'] * $colorrgb2['green']) &gt;&gt; 7);
				$c['blue'] = $colorrgb1['blue'] + $colorrgb2['blue'] - (($colorrgb1['blue'] * $colorrgb2['blue']) &gt;&gt; 7);
				break;

			case IMAGE_TOOLBOX_BLEND_OVERLAY:
				if ($colorrgb1['red'] &lt; 128) {
					$c['red']= ($colorrgb1['red'] * $colorrgb2['red']) &gt;&gt; 7;
				} else {
					$c['red'] = 255 - ((255 - $colorrgb1['red']) * (255 - $colorrgb2['red']) &gt;&gt; 7);
				}
				if ($colorrgb1['green'] &lt; 128) {
					$c['green'] = ($colorrgb1['green'] * $colorrgb2['green']) &gt;&gt; 7;
				} else {
					$c['green'] = 255 - ((255 - $colorrgb1['green']) * (255 - $colorrgb2['green']) &gt;&gt; 7);
				}
				if ($colorrgb1['blue'] &lt; 128) {
					$c['blue'] = ($colorrgb1['blue'] * $colorrgb2['blue']) &gt;&gt; 7;
				} else {
					$c['blue'] = 255 - ((255 - $colorrgb1['blue']) * (255 - $colorrgb2['blue']) &gt;&gt; 7);
				}
				break;

			default:
				break;
		}
		return $c;
	}

	/**
	 * convert iso character coding to unicode (PHP conform)
	 * needed for TTF text generation of special characters (Latin-2)
	 *
	 * @access private
	 */
	function _iso2uni($isoline) {
		$iso2uni = array(
			173 =&gt; "&amp;#161;",
			155 =&gt; "&amp;#162;",
			156 =&gt; "&amp;#163;",
			15 =&gt; "&amp;#164;",
			157 =&gt; "&amp;#165;",
			124 =&gt; "&amp;#166;",
			21 =&gt; "&amp;#167;",
			249 =&gt; "&amp;#168;",
			184 =&gt; "&amp;#169;",
			166 =&gt; "&amp;#170;",
			174 =&gt; "&amp;#171;",
			170 =&gt; "&amp;#172;",
			169 =&gt; "&amp;#174;",
			238 =&gt; "&amp;#175;",
			248 =&gt; "&amp;#176;",
			241 =&gt; "&amp;#177;",
			253 =&gt; "&amp;#178;",
			252 =&gt; "&amp;#179;",
			239 =&gt; "&amp;#180;",
			230 =&gt; "&amp;#181;",
			20 =&gt; "&amp;#182;",
			250 =&gt; "&amp;#183;",
			247 =&gt; "&amp;#184;",
			251 =&gt; "&amp;#185;",
			167 =&gt; "&amp;#186;",
			175 =&gt; "&amp;#187;",
			172 =&gt; "&amp;#188;",
			171 =&gt; "&amp;#189;",
			243 =&gt; "&amp;#190;",
			168 =&gt; "&amp;#191;",
			183 =&gt; "&amp;#192;",
			181 =&gt; "&amp;#193;",
			182 =&gt; "&amp;#194;",
			199 =&gt; "&amp;#195;",
			142 =&gt; "&amp;#196;",
			143 =&gt; "&amp;#197;",
			146 =&gt; "&amp;#198;",
			128 =&gt; "&amp;#199;",
			212 =&gt; "&amp;#200;",
			144 =&gt; "&amp;#201;",
			210 =&gt; "&amp;#202;",
			211 =&gt; "&amp;#203;",
			141 =&gt; "&amp;#204;",
			161 =&gt; "&amp;#205;",
			140 =&gt; "&amp;#206;",
			139 =&gt; "&amp;#207;",
			209 =&gt; "&amp;#208;",
			165 =&gt; "&amp;#209;",
			227 =&gt; "&amp;#210;",
			224 =&gt; "&amp;#211;",
			226 =&gt; "&amp;#212;",
			229 =&gt; "&amp;#213;",
			153 =&gt; "&amp;#214;",
			158 =&gt; "&amp;#215;",
			157 =&gt; "&amp;#216;",
			235 =&gt; "&amp;#217;",
			233 =&gt; "&amp;#218;",
			234 =&gt; "&amp;#219;",
			154 =&gt; "&amp;#220;",
			237 =&gt; "&amp;#221;",
			232 =&gt; "&amp;#222;",
			225 =&gt; "&amp;#223;",
			133 =&gt; "&amp;#224;",
			160 =&gt; "&amp;#225;",
			131 =&gt; "&amp;#226;",
			198 =&gt; "&amp;#227;",
			132 =&gt; "&amp;#228;",
			134 =&gt; "&amp;#229;",
			145 =&gt; "&amp;#230;",
			135 =&gt; "&amp;#231;",
			138 =&gt; "&amp;#232;",
			130 =&gt; "&amp;#233;",
			136 =&gt; "&amp;#234;",
			137 =&gt; "&amp;#235;",
			141 =&gt; "&amp;#236;",
			161 =&gt; "&amp;#237;",
			140 =&gt; "&amp;#238;",
			139 =&gt; "&amp;#239;",
			208 =&gt; "&amp;#240;",
			164 =&gt; "&amp;#241;",
			149 =&gt; "&amp;#242;",
			162 =&gt; "&amp;#243;",
			147 =&gt; "&amp;#244;",
			228 =&gt; "&amp;#245;",
			148 =&gt; "&amp;#246;",
			246 =&gt; "&amp;#247;",
			155 =&gt; "&amp;#248;",
			151 =&gt; "&amp;#249;",
			163 =&gt; "&amp;#250;",
			150 =&gt; "&amp;#251;",
			129 =&gt; "&amp;#252;",
			236 =&gt; "&amp;#253;",
			231 =&gt; "&amp;#254;",
			152 =&gt; "&amp;#255;"
		);
		for ($i=0; $i &lt; strlen($isoline); $i++){
			$thischar = substr($isoline, $i, 1);
			$new = $iso2uni[ord($thischar)];
			$uniline .= ($new != "") ? $new : $thischar;
		}
		return $uniline;
	}
	/**
	 * Writes text over the image
	 *
	 * only TTF fonts are supported at the moment
	 *
	 * $x:&lt;br&gt;
	 * You can also use the following keywords ('left', 'center' or 'middle', 'right').&lt;br&gt;
	 * Additionally you can specify an offset in pixel with the keywords like this 'left +10'.&lt;br&gt;
	 * (default = 0)
	 *
	 * $y:&lt;br&gt;
	 * You can also use the following keywords ('top', 'center' or 'middle', 'bottom').&lt;br&gt;
	 * Additionally you can specify an offset in pixel with the keywords like this 'bottom -10'.&lt;br&gt;
	 * (default = 0)
	 *
	 * @param string $text text to be generated.
	 * @param string $font TTF fontfile to be used. (relative paths are ok).
	 * @param integer $size textsize.
	 * @param string $color textcolor in hexformat (e.g. '#FF0000').
	 * @param string|integer $x horizontal postion in pixel.
	 * @param string|integer $y vertical postion in pixel.
	 * @param integer $angle rotation of the text.
	 */
	function addText($text, $font, $size, $color, $x, $y, $angle = 0) {
		global $HTTP_SERVER_VARS;

		if (substr($font, 0, 1) == '/') {
			$prepath = '';
		} else {
			$prepath = substr($HTTP_SERVER_VARS['SCRIPT_FILENAME'], 0, strrpos($HTTP_SERVER_VARS['SCRIPT_FILENAME'], '/')) . '/';
		}
		$text = $this-&gt;_iso2uni($text);
		if (is_string($x) || is_string($y)) {
			$textsize = imagettfbbox($size, $angle, $prepath.$font, $text);
			$textwidth = abs($textsize[2]);
			$textheight = abs($textsize[7]);
			list($xalign, $xalign_offset) = explode(" ", $x);
			list($yalign, $yalign_offset) = explode(" ", $y);
		}
		if (is_string($x)) {
			switch ($xalign) {
				case 'left':
					$x = 0 + $xalign_offset;
					break;

				case 'right':
					$x = ($this-&gt;_img['main']['width'] - $textwidth) + $xalign_offset;
					break;

				case 'middle':
				case 'center':
					$x = (($this-&gt;_img['main']['width'] - $textwidth) / 2) + $xalign_offset;
					break;
			}
		}
		if (is_string($y)) {
			switch ($yalign) {
				case 'top':
					$y = (0 + $textheight) + $yalign_offset;
					break;

				case 'bottom':
					$y = ($this-&gt;_img['main']['height']) + $yalign_offset;
					break;

				case 'middle':
				case 'center':
					$y = ((($this-&gt;_img['main']['height'] - $textheight) / 2) + $textheight) + $yalign_offset;
					break;
			}
		}
		imagettftext($this-&gt;_img['main']['resource'], $size, $angle, $x, $y, $this-&gt;_hexToPHPColor($color), $prepath . $font, $text);
		return true;
	}

}
</PRE>
</BODY>
</HTML>
